## Асинхронная поддержка IO ##
================================================================================================
|        |                        |
|:-:     |---                     |
|PEP     |3153                    |
|Заголово|Асинхронная поддержка IO|
|Автор   |Laurens Van Houtven <_ at lvh.cc>|
|Статус  |Заменено                |
|Создано |29 мая 2011             |
|Post-History|TBD                 |
|Кем заменено|3156                |

-----------------------------------------------------------------------------------------------
# Содержание #
* Аннотация
* Обьяснение
* Взаимодействие абстракций
  * Транспортировка
  * Протоколы
  * Зачем отделять протоколы от транспортировки
* Контроль потока
  * Потребители
  * Поставщики
    * Рассмотренные API альтернативы
      * Генераторы как поставщики
* Рекомендации
* Авторское право

# Аннотация #
Данный PEP описывает абстракции асинхронного IO для библиотеки Python

Цель состоит в том, чтобы достичь абстракцию, которая может быть реализована с помощью различных 
асинхронных обработчиков ввода-вывода и несет цель библиотеки, написание переносимого кода между различными 
подсистемами.

# Обьяснение #
Люди, которые хотят писать асинхронный код на Python уже сейчас, есть несколько вариантов:

* asyncore и asynchat
* Писать на основе выбранного модуля(something bespoke, most likely based on the select module)
* Использовать сторонние библиотеки, такие как Twisted или gevent

К сожалению, каждый из этих вариантов имеет свои недостатки, которые данный PEP пытается решить.

Несмотря на то, что долгое время были частью стандартной библиотеки Python, модуль asyncore, от основных 
недостатков, вытекающих из не гибкого API, что не выдерживает ожидания от современного асинхронного 
сетевого модуля.

Кроме того, его подход является слишком упращенным для разработчиков со всеми их инструментами, необходимыми 
для того, чтобы полностью использовать потенциал асинхронной сети.

Наиболее популярным решением в продакшене сейчас пользуются сторонние библиотеки. Они часто обеспечивают 
удовлетворительное решение, но отсутствует совместимость между разными библиотеками, поэтому библитеки тесно связаны 
с программами, которые их используют.
  
Это отсутствие переносимости между разными библиотеками асинхронного ввода-вывода, требует приложить много 
усилий для дублирования в работе при использовании сторонних библиотек. Достаточно хорошие абстракции могут 
позволить написать код единожды, но использовать повсеместно.

В конечном счете цель стандарной библиотеки реализация соединения сетевого протокола в рабочей(реальной) библиотеке, 
 в отличии от автономных библиотек, которые делают все, включая вызовы recv() блокировки. Это означает что, 
 они могут быть легко использованы как в синхронном, так и асинхронном коде.